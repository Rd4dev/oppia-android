<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Coverage Report</title>
  <style>
    body {
        font-family: Arial, sans-serif;
        font-size: 12px;
        line-height: 1.6;
        padding: 20px;
    }
    table {
        width: 100%;
        border-collapse: collapse;
        margin-bottom: 20px;
    }
    th, td {
        padding: 8px;
        margin-left: 20px;
        text-align: left;
        white-space: pre-wrap;
        border-bottom: 1px solid #e3e3e3;
    }
    .line-number-col {
        width: 4%;
    }
    .line-number-row {
        border-right: 1px solid #ababab
    }
    .source-code-col {
        width: 96%;
    }
    .covered-line, .not-covered-line, .uncovered-line {
        /*white-space: pre-wrap;*/
    }
    .covered-line {
        background-color: #c8e6c9; /* Light green */
    }
    .not-covered-line {
        background-color: #ffcdd2; /* Light red */
    }
    .uncovered-line {
        background-color: #f7f7f7; /* light gray */
    }
    .coverage-summary {
      margin-bottom: 20px;
    }
    h2 {
      text-align: center;
    }
    ul {
      list-style-type: none;
      padding: 0;
      text-align: center;
    }
    .summary-box {
      border: 1px solid #ccc;
      border-radius: 8px;
      padding: 10px;
      margin-bottom: 20px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
    }
    .summary-left {
      text-align: left;
    }
    .summary-right {
      text-align: right;
    }
    .legend {
      display: flex;
      align-items: center;
    }
    .legend-item {
      width: 20px;
      height: 10px;
      margin-right: 5px;
      border-radius: 2px;
      display: inline-block;
    }
    .legend .covered {
      background-color: #c8e6c9; /* Light green */
    }
    .legend .not-covered {
      margin-left: 4px;
      background-color: #ffcdd2; /* Light red */
    }
    @media screen and (max-width: 768px) {
      body {
          padding: 10px;
      }
      table {
          width: auto;
      }
    }
  </style>
</head>
<body>
  <h2>Coverage Report</h2>
  <div class="summary-box">
    <div class="summary-left">
      <strong>Covered File:</strong> utility/src/main/java/org/oppia/android/util/math/MathTokenizer.kt <br>
      <div class="legend">
        <div class="legend-item covered"></div>
        <span>Covered</span>
        <div class="legend-item not-covered"></div>
        <span>Uncovered</span>
      </div>
    </div>
    <div class="summary-right">
      <div><strong>Coverage percentage:</strong> 94.26%</div>
      <div><strong>Line coverage:</strong> 197 / 209 covered</div>
    </div>
  </div>
  <table>
    <thead>
      <tr>
        <th class="line-number-col">Line No</th>
        <th class="source-code-col">Source Code</th>
      </tr>
    </thead>
    <tbody><tr>
    <td class="line-number-row">   1</td>
    <td class="uncovered-line">package org.oppia.android.util.math</td>
</tr><tr>
    <td class="line-number-row">   2</td>
    <td class="uncovered-line"></td>
</tr><tr>
    <td class="line-number-row">   3</td>
    <td class="uncovered-line">import org.oppia.android.app.model.MathBinaryOperation</td>
</tr><tr>
    <td class="line-number-row">   4</td>
    <td class="uncovered-line">import org.oppia.android.app.model.MathBinaryOperation.Operator.ADD</td>
</tr><tr>
    <td class="line-number-row">   5</td>
    <td class="uncovered-line">import org.oppia.android.app.model.MathBinaryOperation.Operator.DIVIDE</td>
</tr><tr>
    <td class="line-number-row">   6</td>
    <td class="uncovered-line">import org.oppia.android.app.model.MathBinaryOperation.Operator.EXPONENTIATE</td>
</tr><tr>
    <td class="line-number-row">   7</td>
    <td class="uncovered-line">import org.oppia.android.app.model.MathBinaryOperation.Operator.MULTIPLY</td>
</tr><tr>
    <td class="line-number-row">   8</td>
    <td class="uncovered-line">import org.oppia.android.app.model.MathBinaryOperation.Operator.SUBTRACT</td>
</tr><tr>
    <td class="line-number-row">   9</td>
    <td class="uncovered-line">import org.oppia.android.app.model.MathUnaryOperation</td>
</tr><tr>
    <td class="line-number-row">  10</td>
    <td class="uncovered-line">import org.oppia.android.app.model.MathUnaryOperation.Operator.NEGATE</td>
</tr><tr>
    <td class="line-number-row">  11</td>
    <td class="uncovered-line">import org.oppia.android.app.model.MathUnaryOperation.Operator.POSITIVE</td>
</tr><tr>
    <td class="line-number-row">  12</td>
    <td class="uncovered-line">import org.oppia.android.util.math.PeekableIterator.Companion.toPeekableIterator</td>
</tr><tr>
    <td class="line-number-row">  13</td>
    <td class="uncovered-line">import java.lang.StringBuilder</td>
</tr><tr>
    <td class="line-number-row">  14</td>
    <td class="uncovered-line"></td>
</tr><tr>
    <td class="line-number-row">  15</td>
    <td class="uncovered-line">/**</td>
</tr><tr>
    <td class="line-number-row">  16</td>
    <td class="uncovered-line"> * Input tokenizer for math (numeric & algebraic) expressions and equations.</td>
</tr><tr>
    <td class="line-number-row">  17</td>
    <td class="uncovered-line"> *</td>
</tr><tr>
    <td class="line-number-row">  18</td>
    <td class="uncovered-line"> * See https://docs.google.com/document/d/1JMpbjqRqdEpye67HvDoqBo_rtScY9oEaB7SwKBBspss/edit for the</td>
</tr><tr>
    <td class="line-number-row">  19</td>
    <td class="uncovered-line"> * grammar specification supported by this tokenizer.</td>
</tr><tr>
    <td class="line-number-row">  20</td>
    <td class="uncovered-line"> *</td>
</tr><tr>
    <td class="line-number-row">  21</td>
    <td class="uncovered-line"> * This class implements an LL(1) single-pass tokenizer with no caching. Use [tokenize] to produce a</td>
</tr><tr>
    <td class="line-number-row">  22</td>
    <td class="uncovered-line"> * sequence of [Token]s from the given input stream.</td>
</tr><tr>
    <td class="line-number-row">  23</td>
    <td class="uncovered-line"> */</td>
</tr><tr>
    <td class="line-number-row">  24</td>
    <td class="uncovered-line">class MathTokenizer private constructor() {</td>
</tr><tr>
    <td class="line-number-row">  25</td>
    <td class="uncovered-line">  companion object {</td>
</tr><tr>
    <td class="line-number-row">  26</td>
    <td class="uncovered-line">    /**</td>
</tr><tr>
    <td class="line-number-row">  27</td>
    <td class="uncovered-line">     * Returns a [Sequence] of [Token]s for the specified input string.</td>
</tr><tr>
    <td class="line-number-row">  28</td>
    <td class="uncovered-line">     *</td>
</tr><tr>
    <td class="line-number-row">  29</td>
    <td class="uncovered-line">     * Note that this tokenizer will attempt to recover if an invalid token is encountered (i.e.</td>
</tr><tr>
    <td class="line-number-row">  30</td>
    <td class="uncovered-line">     * tokenization will continue). Further, tokenization occurs lazily (i.e. as the sequence is</td>
</tr><tr>
    <td class="line-number-row">  31</td>
    <td class="uncovered-line">     * traversed), so calling this method is essentially zero-cost until tokens are actually needed.</td>
</tr><tr>
    <td class="line-number-row">  32</td>
    <td class="uncovered-line">     * The sequence should be converted to a [List] if they need to be retained after initial</td>
</tr><tr>
    <td class="line-number-row">  33</td>
    <td class="uncovered-line">     * tokenization since the sequence retains no memory.</td>
</tr><tr>
    <td class="line-number-row">  34</td>
    <td class="uncovered-line">     */</td>
</tr><tr>
    <td class="line-number-row">  35</td>
    <td class="covered-line">    fun tokenize(input: String): Sequence<Token> = tokenize(input.toCharArray().asSequence())</td>
</tr><tr>
    <td class="line-number-row">  36</td>
    <td class="uncovered-line"></td>
</tr><tr>
    <td class="line-number-row">  37</td>
    <td class="uncovered-line">    private fun tokenize(input: Sequence<Char>): Sequence<Token> {</td>
</tr><tr>
    <td class="line-number-row">  38</td>
    <td class="covered-line">      val chars = input.toPeekableIterator()</td>
</tr><tr>
    <td class="line-number-row">  39</td>
    <td class="covered-line">      return generateSequence {</td>
</tr><tr>
    <td class="line-number-row">  40</td>
    <td class="uncovered-line">        // Consume any whitespace that might precede a valid token.</td>
</tr><tr>
    <td class="line-number-row">  41</td>
    <td class="covered-line">        chars.consumeWhitespace()</td>
</tr><tr>
    <td class="line-number-row">  42</td>
    <td class="uncovered-line"></td>
</tr><tr>
    <td class="line-number-row">  43</td>
    <td class="uncovered-line">        // Parse the next token from the underlying sequence.</td>
</tr><tr>
    <td class="line-number-row">  44</td>
    <td class="covered-line">        when (chars.peek()) {</td>
</tr><tr>
    <td class="line-number-row">  45</td>
    <td class="covered-line">          in '0'..'9' -> tokenizeIntegerOrRealNumber(chars)</td>
</tr><tr>
    <td class="line-number-row">  46</td>
    <td class="covered-line">          in 'a'..'z', in 'A'..'Z' -> tokenizeVariableOrFunctionName(chars)</td>
</tr><tr>
    <td class="line-number-row">  47</td>
    <td class="covered-line">          'âˆš' -> tokenizeSymbol(chars) { startIndex, endIndex -></td>
</tr><tr>
    <td class="line-number-row">  48</td>
    <td class="covered-line">            Token.SquareRootSymbol(startIndex, endIndex)</td>
</tr><tr>
    <td class="line-number-row">  49</td>
    <td class="uncovered-line">          }</td>
</tr><tr>
    <td class="line-number-row">  50</td>
    <td class="covered-line">          '+' -> tokenizeSymbol(chars) { startIndex, endIndex -></td>
</tr><tr>
    <td class="line-number-row">  51</td>
    <td class="covered-line">            Token.PlusSymbol(startIndex, endIndex)</td>
</tr><tr>
    <td class="line-number-row">  52</td>
    <td class="uncovered-line">          }</td>
</tr><tr>
    <td class="line-number-row">  53</td>
    <td class="covered-line">          '-', 'âˆ’', 'â€“' -> tokenizeSymbol(chars) { startIndex, endIndex -></td>
</tr><tr>
    <td class="line-number-row">  54</td>
    <td class="covered-line">            Token.MinusSymbol(startIndex, endIndex)</td>
</tr><tr>
    <td class="line-number-row">  55</td>
    <td class="uncovered-line">          }</td>
</tr><tr>
    <td class="line-number-row">  56</td>
    <td class="covered-line">          '*', 'Ã—' -> tokenizeSymbol(chars) { startIndex, endIndex -></td>
</tr><tr>
    <td class="line-number-row">  57</td>
    <td class="covered-line">            Token.MultiplySymbol(startIndex, endIndex)</td>
</tr><tr>
    <td class="line-number-row">  58</td>
    <td class="uncovered-line">          }</td>
</tr><tr>
    <td class="line-number-row">  59</td>
    <td class="covered-line">          '/', 'Ã·' -> tokenizeSymbol(chars) { startIndex, endIndex -></td>
</tr><tr>
    <td class="line-number-row">  60</td>
    <td class="covered-line">            Token.DivideSymbol(startIndex, endIndex)</td>
</tr><tr>
    <td class="line-number-row">  61</td>
    <td class="uncovered-line">          }</td>
</tr><tr>
    <td class="line-number-row">  62</td>
    <td class="covered-line">          '^' -> tokenizeSymbol(chars) { startIndex, endIndex -></td>
</tr><tr>
    <td class="line-number-row">  63</td>
    <td class="covered-line">            Token.ExponentiationSymbol(startIndex, endIndex)</td>
</tr><tr>
    <td class="line-number-row">  64</td>
    <td class="uncovered-line">          }</td>
</tr><tr>
    <td class="line-number-row">  65</td>
    <td class="covered-line">          '=' -> tokenizeSymbol(chars) { startIndex, endIndex -></td>
</tr><tr>
    <td class="line-number-row">  66</td>
    <td class="covered-line">            Token.EqualsSymbol(startIndex, endIndex)</td>
</tr><tr>
    <td class="line-number-row">  67</td>
    <td class="uncovered-line">          }</td>
</tr><tr>
    <td class="line-number-row">  68</td>
    <td class="covered-line">          '(' -> tokenizeSymbol(chars) { startIndex, endIndex -></td>
</tr><tr>
    <td class="line-number-row">  69</td>
    <td class="covered-line">            Token.LeftParenthesisSymbol(startIndex, endIndex)</td>
</tr><tr>
    <td class="line-number-row">  70</td>
    <td class="uncovered-line">          }</td>
</tr><tr>
    <td class="line-number-row">  71</td>
    <td class="covered-line">          ')' -> tokenizeSymbol(chars) { startIndex, endIndex -></td>
</tr><tr>
    <td class="line-number-row">  72</td>
    <td class="covered-line">            Token.RightParenthesisSymbol(startIndex, endIndex)</td>
</tr><tr>
    <td class="line-number-row">  73</td>
    <td class="uncovered-line">          }</td>
</tr><tr>
    <td class="line-number-row">  74</td>
    <td class="covered-line">          null -> null // End of stream.</td>
</tr><tr>
    <td class="line-number-row">  75</td>
    <td class="uncovered-line">          // Invalid character.</td>
</tr><tr>
    <td class="line-number-row">  76</td>
    <td class="covered-line">          else -> tokenizeSymbol(chars) { startIndex, endIndex -></td>
</tr><tr>
    <td class="line-number-row">  77</td>
    <td class="covered-line">            Token.InvalidToken(startIndex, endIndex)</td>
</tr><tr>
    <td class="line-number-row">  78</td>
    <td class="uncovered-line">          }</td>
</tr><tr>
    <td class="line-number-row">  79</td>
    <td class="uncovered-line">        }</td>
</tr><tr>
    <td class="line-number-row">  80</td>
    <td class="uncovered-line">      }</td>
</tr><tr>
    <td class="line-number-row">  81</td>
    <td class="uncovered-line">    }</td>
</tr><tr>
    <td class="line-number-row">  82</td>
    <td class="uncovered-line"></td>
</tr><tr>
    <td class="line-number-row">  83</td>
    <td class="uncovered-line">    private fun tokenizeIntegerOrRealNumber(chars: PeekableIterator<Char>): Token {</td>
</tr><tr>
    <td class="line-number-row">  84</td>
    <td class="covered-line">      val startIndex = chars.getRetrievalCount()</td>
</tr><tr>
    <td class="line-number-row">  85</td>
    <td class="covered-line">      val integerPart1 =</td>
</tr><tr>
    <td class="line-number-row">  86</td>
    <td class="covered-line">        parseInteger(chars)</td>
</tr><tr>
    <td class="line-number-row">  87</td>
    <td class="not-covered-line">          ?: return Token.InvalidToken(startIndex, endIndex = chars.getRetrievalCount())</td>
</tr><tr>
    <td class="line-number-row">  88</td>
    <td class="covered-line">      val integerEndIndex = chars.getRetrievalCount() // The end index for integers.</td>
</tr><tr>
    <td class="line-number-row">  89</td>
    <td class="covered-line">      chars.consumeWhitespace() // Whitespace is allowed between digits and the '.'.</td>
</tr><tr>
    <td class="line-number-row">  90</td>
    <td class="covered-line">      return if (chars.peek() == '.') {</td>
</tr><tr>
    <td class="line-number-row">  91</td>
    <td class="covered-line">        chars.next() // Parse the "." since it will be re-added later.</td>
</tr><tr>
    <td class="line-number-row">  92</td>
    <td class="covered-line">        chars.consumeWhitespace() // Whitespace is allowed between the '.' and following digits.</td>
</tr><tr>
    <td class="line-number-row">  93</td>
    <td class="uncovered-line"></td>
</tr><tr>
    <td class="line-number-row">  94</td>
    <td class="uncovered-line">        // Another integer must follow the ".".</td>
</tr><tr>
    <td class="line-number-row">  95</td>
    <td class="covered-line">        val integerPart2 = parseInteger(chars)</td>
</tr><tr>
    <td class="line-number-row">  96</td>
    <td class="covered-line">          ?: return Token.InvalidToken(startIndex, endIndex = chars.getRetrievalCount())</td>
</tr><tr>
    <td class="line-number-row">  97</td>
    <td class="uncovered-line"></td>
</tr><tr>
    <td class="line-number-row">  98</td>
    <td class="covered-line">        val doubleValue = "$integerPart1.$integerPart2".toValidDoubleOrNull()</td>
</tr><tr>
    <td class="line-number-row">  99</td>
    <td class="covered-line">          ?: return Token.InvalidToken(startIndex, endIndex = chars.getRetrievalCount())</td>
</tr><tr>
    <td class="line-number-row"> 100</td>
    <td class="covered-line">        Token.PositiveRealNumber(doubleValue, startIndex, endIndex = chars.getRetrievalCount())</td>
</tr><tr>
    <td class="line-number-row"> 101</td>
    <td class="uncovered-line">      } else {</td>
</tr><tr>
    <td class="line-number-row"> 102</td>
    <td class="covered-line">        Token.PositiveInteger(</td>
</tr><tr>
    <td class="line-number-row"> 103</td>
    <td class="covered-line">          integerPart1.toIntOrNull()</td>
</tr><tr>
    <td class="line-number-row"> 104</td>
    <td class="covered-line">            ?: return Token.InvalidToken(startIndex, endIndex = chars.getRetrievalCount()),</td>
</tr><tr>
    <td class="line-number-row"> 105</td>
    <td class="covered-line">          startIndex,</td>
</tr><tr>
    <td class="line-number-row"> 106</td>
    <td class="covered-line">          integerEndIndex</td>
</tr><tr>
    <td class="line-number-row"> 107</td>
    <td class="uncovered-line">        )</td>
</tr><tr>
    <td class="line-number-row"> 108</td>
    <td class="uncovered-line">      }</td>
</tr><tr>
    <td class="line-number-row"> 109</td>
    <td class="uncovered-line">    }</td>
</tr><tr>
    <td class="line-number-row"> 110</td>
    <td class="uncovered-line"></td>
</tr><tr>
    <td class="line-number-row"> 111</td>
    <td class="uncovered-line">    private fun tokenizeVariableOrFunctionName(chars: PeekableIterator<Char>): Token {</td>
</tr><tr>
    <td class="line-number-row"> 112</td>
    <td class="covered-line">      val startIndex = chars.getRetrievalCount()</td>
</tr><tr>
    <td class="line-number-row"> 113</td>
    <td class="covered-line">      val firstChar = chars.next()</td>
</tr><tr>
    <td class="line-number-row"> 114</td>
    <td class="uncovered-line"></td>
</tr><tr>
    <td class="line-number-row"> 115</td>
    <td class="uncovered-line">      // latin_letter = lowercase_latin_letter | uppercase_latin_letter ;</td>
</tr><tr>
    <td class="line-number-row"> 116</td>
    <td class="uncovered-line">      // variable = latin_letter ;</td>
</tr><tr>
    <td class="line-number-row"> 117</td>
    <td class="covered-line">      return tokenizeFunctionName(firstChar, startIndex, chars)</td>
</tr><tr>
    <td class="line-number-row"> 118</td>
    <td class="covered-line">        ?: Token.VariableName(</td>
</tr><tr>
    <td class="line-number-row"> 119</td>
    <td class="covered-line">          firstChar.toString(), startIndex, endIndex = chars.getRetrievalCount()</td>
</tr><tr>
    <td class="line-number-row"> 120</td>
    <td class="uncovered-line">        )</td>
</tr><tr>
    <td class="line-number-row"> 121</td>
    <td class="uncovered-line">    }</td>
</tr><tr>
    <td class="line-number-row"> 122</td>
    <td class="uncovered-line"></td>
</tr><tr>
    <td class="line-number-row"> 123</td>
    <td class="uncovered-line">    private fun tokenizeFunctionName(</td>
</tr><tr>
    <td class="line-number-row"> 124</td>
    <td class="uncovered-line">      currChar: Char,</td>
</tr><tr>
    <td class="line-number-row"> 125</td>
    <td class="uncovered-line">      startIndex: Int,</td>
</tr><tr>
    <td class="line-number-row"> 126</td>
    <td class="uncovered-line">      chars: PeekableIterator<Char></td>
</tr><tr>
    <td class="line-number-row"> 127</td>
    <td class="uncovered-line">    ): Token? {</td>
</tr><tr>
    <td class="line-number-row"> 128</td>
    <td class="uncovered-line">      // allowed_function_name = "sqrt" ;</td>
</tr><tr>
    <td class="line-number-row"> 129</td>
    <td class="uncovered-line">      // disallowed_function_name =</td>
</tr><tr>
    <td class="line-number-row"> 130</td>
    <td class="uncovered-line">      //     "exp" | "log" | "log10" | "ln" | "sin" | "cos" | "tan" | "cot" | "csc"</td>
</tr><tr>
    <td class="line-number-row"> 131</td>
    <td class="uncovered-line">      //     | "sec" | "atan" | "asin" | "acos" | "abs" ;</td>
</tr><tr>
    <td class="line-number-row"> 132</td>
    <td class="uncovered-line">      // function_name = allowed_function_name | disallowed_function_name ;</td>
</tr><tr>
    <td class="line-number-row"> 133</td>
    <td class="covered-line">      val nextChar = chars.peek()</td>
</tr><tr>
    <td class="line-number-row"> 134</td>
    <td class="covered-line">      return when (currChar) {</td>
</tr><tr>
    <td class="line-number-row"> 135</td>
    <td class="covered-line">        'a' -> {</td>
</tr><tr>
    <td class="line-number-row"> 136</td>
    <td class="uncovered-line">          // abs, acos, asin, atan, or variable.</td>
</tr><tr>
    <td class="line-number-row"> 137</td>
    <td class="covered-line">          when (nextChar) {</td>
</tr><tr>
    <td class="line-number-row"> 138</td>
    <td class="covered-line">            'b' -></td>
</tr><tr>
    <td class="line-number-row"> 139</td>
    <td class="covered-line">              tokenizeExpectedFunction(name = "abs", isAllowedFunction = false, startIndex, chars)</td>
</tr><tr>
    <td class="line-number-row"> 140</td>
    <td class="covered-line">            'c' -></td>
</tr><tr>
    <td class="line-number-row"> 141</td>
    <td class="covered-line">              tokenizeExpectedFunction(name = "acos", isAllowedFunction = false, startIndex, chars)</td>
</tr><tr>
    <td class="line-number-row"> 142</td>
    <td class="covered-line">            's' -></td>
</tr><tr>
    <td class="line-number-row"> 143</td>
    <td class="covered-line">              tokenizeExpectedFunction(name = "asin", isAllowedFunction = false, startIndex, chars)</td>
</tr><tr>
    <td class="line-number-row"> 144</td>
    <td class="covered-line">            't' -></td>
</tr><tr>
    <td class="line-number-row"> 145</td>
    <td class="covered-line">              tokenizeExpectedFunction(name = "atan", isAllowedFunction = false, startIndex, chars)</td>
</tr><tr>
    <td class="line-number-row"> 146</td>
    <td class="covered-line">            else -> null // Must be a variable.</td>
</tr><tr>
    <td class="line-number-row"> 147</td>
    <td class="uncovered-line">          }</td>
</tr><tr>
    <td class="line-number-row"> 148</td>
    <td class="uncovered-line">        }</td>
</tr><tr>
    <td class="line-number-row"> 149</td>
    <td class="covered-line">        'c' -> {</td>
</tr><tr>
    <td class="line-number-row"> 150</td>
    <td class="uncovered-line">          // cos, cot, csc, or variable.</td>
</tr><tr>
    <td class="line-number-row"> 151</td>
    <td class="covered-line">          when (nextChar) {</td>
</tr><tr>
    <td class="line-number-row"> 152</td>
    <td class="covered-line">            'o' -> {</td>
</tr><tr>
    <td class="line-number-row"> 153</td>
    <td class="covered-line">              chars.next() // Skip the 'o' to go to the last character.</td>
</tr><tr>
    <td class="line-number-row"> 154</td>
    <td class="covered-line">              val name = if (chars.peek() == 's') {</td>
</tr><tr>
    <td class="line-number-row"> 155</td>
    <td class="covered-line">                chars.expectNextMatches { it == 's' }</td>
</tr><tr>
    <td class="line-number-row"> 156</td>
    <td class="not-covered-line">                  ?: return Token.IncompleteFunctionName(</td>
</tr><tr>
    <td class="line-number-row"> 157</td>
    <td class="not-covered-line">                    startIndex, endIndex = chars.getRetrievalCount()</td>
</tr><tr>
    <td class="line-number-row"> 158</td>
    <td class="uncovered-line">                  )</td>
</tr><tr>
    <td class="line-number-row"> 159</td>
    <td class="covered-line">                "cos"</td>
</tr><tr>
    <td class="line-number-row"> 160</td>
    <td class="uncovered-line">              } else {</td>
</tr><tr>
    <td class="line-number-row"> 161</td>
    <td class="uncovered-line">                // Otherwise, it must be 'c' for 'cot' since the parser can't backtrack.</td>
</tr><tr>
    <td class="line-number-row"> 162</td>
    <td class="covered-line">                chars.expectNextMatches { it == 't' }</td>
</tr><tr>
    <td class="line-number-row"> 163</td>
    <td class="covered-line">                  ?: return Token.IncompleteFunctionName(</td>
</tr><tr>
    <td class="line-number-row"> 164</td>
    <td class="covered-line">                    startIndex, endIndex = chars.getRetrievalCount()</td>
</tr><tr>
    <td class="line-number-row"> 165</td>
    <td class="uncovered-line">                  )</td>
</tr><tr>
    <td class="line-number-row"> 166</td>
    <td class="covered-line">                "cot"</td>
</tr><tr>
    <td class="line-number-row"> 167</td>
    <td class="uncovered-line">              }</td>
</tr><tr>
    <td class="line-number-row"> 168</td>
    <td class="covered-line">              Token.FunctionName(</td>
</tr><tr>
    <td class="line-number-row"> 169</td>
    <td class="covered-line">                name, isAllowedFunction = false, startIndex, endIndex = chars.getRetrievalCount()</td>
</tr><tr>
    <td class="line-number-row"> 170</td>
    <td class="uncovered-line">              )</td>
</tr><tr>
    <td class="line-number-row"> 171</td>
    <td class="uncovered-line">            }</td>
</tr><tr>
    <td class="line-number-row"> 172</td>
    <td class="covered-line">            's' -></td>
</tr><tr>
    <td class="line-number-row"> 173</td>
    <td class="covered-line">              tokenizeExpectedFunction(name = "csc", isAllowedFunction = false, startIndex, chars)</td>
</tr><tr>
    <td class="line-number-row"> 174</td>
    <td class="covered-line">            else -> null // Must be a variable.</td>
</tr><tr>
    <td class="line-number-row"> 175</td>
    <td class="uncovered-line">          }</td>
</tr><tr>
    <td class="line-number-row"> 176</td>
    <td class="uncovered-line">        }</td>
</tr><tr>
    <td class="line-number-row"> 177</td>
    <td class="covered-line">        'e' -> {</td>
</tr><tr>
    <td class="line-number-row"> 178</td>
    <td class="uncovered-line">          // exp or variable.</td>
</tr><tr>
    <td class="line-number-row"> 179</td>
    <td class="covered-line">          if (nextChar == 'x') {</td>
</tr><tr>
    <td class="line-number-row"> 180</td>
    <td class="covered-line">            tokenizeExpectedFunction(name = "exp", isAllowedFunction = false, startIndex, chars)</td>
</tr><tr>
    <td class="line-number-row"> 181</td>
    <td class="covered-line">          } else null // Must be a variable.</td>
</tr><tr>
    <td class="line-number-row"> 182</td>
    <td class="uncovered-line">        }</td>
</tr><tr>
    <td class="line-number-row"> 183</td>
    <td class="covered-line">        'l' -> {</td>
</tr><tr>
    <td class="line-number-row"> 184</td>
    <td class="uncovered-line">          // ln, log, log10, or variable.</td>
</tr><tr>
    <td class="line-number-row"> 185</td>
    <td class="covered-line">          when (nextChar) {</td>
</tr><tr>
    <td class="line-number-row"> 186</td>
    <td class="covered-line">            'n' -></td>
</tr><tr>
    <td class="line-number-row"> 187</td>
    <td class="covered-line">              tokenizeExpectedFunction(name = "ln", isAllowedFunction = false, startIndex, chars)</td>
</tr><tr>
    <td class="line-number-row"> 188</td>
    <td class="covered-line">            'o' -> {</td>
</tr><tr>
    <td class="line-number-row"> 189</td>
    <td class="uncovered-line">              // Skip the 'o'. Following the 'o' must be a 'g' since the parser can't backtrack.</td>
</tr><tr>
    <td class="line-number-row"> 190</td>
    <td class="covered-line">              chars.next()</td>
</tr><tr>
    <td class="line-number-row"> 191</td>
    <td class="covered-line">              chars.expectNextMatches { it == 'g' }</td>
</tr><tr>
    <td class="line-number-row"> 192</td>
    <td class="covered-line">                ?: return Token.IncompleteFunctionName(</td>
</tr><tr>
    <td class="line-number-row"> 193</td>
    <td class="covered-line">                  startIndex, endIndex = chars.getRetrievalCount()</td>
</tr><tr>
    <td class="line-number-row"> 194</td>
    <td class="uncovered-line">                )</td>
</tr><tr>
    <td class="line-number-row"> 195</td>
    <td class="covered-line">              val name = if (chars.peek() == '1') {</td>
</tr><tr>
    <td class="line-number-row"> 196</td>
    <td class="uncovered-line">                // '10' must be next for 'log10'.</td>
</tr><tr>
    <td class="line-number-row"> 197</td>
    <td class="covered-line">                chars.expectNextMatches { it == '1' }</td>
</tr><tr>
    <td class="line-number-row"> 198</td>
    <td class="not-covered-line">                  ?: return Token.IncompleteFunctionName(</td>
</tr><tr>
    <td class="line-number-row"> 199</td>
    <td class="not-covered-line">                    startIndex, endIndex = chars.getRetrievalCount()</td>
</tr><tr>
    <td class="line-number-row"> 200</td>
    <td class="uncovered-line">                  )</td>
</tr><tr>
    <td class="line-number-row"> 201</td>
    <td class="covered-line">                chars.expectNextMatches { it == '0' }</td>
</tr><tr>
    <td class="line-number-row"> 202</td>
    <td class="covered-line">                  ?: return Token.IncompleteFunctionName(</td>
</tr><tr>
    <td class="line-number-row"> 203</td>
    <td class="covered-line">                    startIndex, endIndex = chars.getRetrievalCount()</td>
</tr><tr>
    <td class="line-number-row"> 204</td>
    <td class="uncovered-line">                  )</td>
</tr><tr>
    <td class="line-number-row"> 205</td>
    <td class="covered-line">                "log10"</td>
</tr><tr>
    <td class="line-number-row"> 206</td>
    <td class="covered-line">              } else "log"</td>
</tr><tr>
    <td class="line-number-row"> 207</td>
    <td class="covered-line">              Token.FunctionName(</td>
</tr><tr>
    <td class="line-number-row"> 208</td>
    <td class="covered-line">                name, isAllowedFunction = false, startIndex, endIndex = chars.getRetrievalCount()</td>
</tr><tr>
    <td class="line-number-row"> 209</td>
    <td class="uncovered-line">              )</td>
</tr><tr>
    <td class="line-number-row"> 210</td>
    <td class="uncovered-line">            }</td>
</tr><tr>
    <td class="line-number-row"> 211</td>
    <td class="covered-line">            else -> null // Must be a variable.</td>
</tr><tr>
    <td class="line-number-row"> 212</td>
    <td class="uncovered-line">          }</td>
</tr><tr>
    <td class="line-number-row"> 213</td>
    <td class="uncovered-line">        }</td>
</tr><tr>
    <td class="line-number-row"> 214</td>
    <td class="covered-line">        's' -> {</td>
</tr><tr>
    <td class="line-number-row"> 215</td>
    <td class="uncovered-line">          // sec, sin, sqrt, or variable.</td>
</tr><tr>
    <td class="line-number-row"> 216</td>
    <td class="covered-line">          when (nextChar) {</td>
</tr><tr>
    <td class="line-number-row"> 217</td>
    <td class="covered-line">            'e' -></td>
</tr><tr>
    <td class="line-number-row"> 218</td>
    <td class="covered-line">              tokenizeExpectedFunction(name = "sec", isAllowedFunction = false, startIndex, chars)</td>
</tr><tr>
    <td class="line-number-row"> 219</td>
    <td class="covered-line">            'i' -></td>
</tr><tr>
    <td class="line-number-row"> 220</td>
    <td class="covered-line">              tokenizeExpectedFunction(name = "sin", isAllowedFunction = false, startIndex, chars)</td>
</tr><tr>
    <td class="line-number-row"> 221</td>
    <td class="covered-line">            'q' -></td>
</tr><tr>
    <td class="line-number-row"> 222</td>
    <td class="covered-line">              tokenizeExpectedFunction(name = "sqrt", isAllowedFunction = true, startIndex, chars)</td>
</tr><tr>
    <td class="line-number-row"> 223</td>
    <td class="covered-line">            else -> null // Must be a variable.</td>
</tr><tr>
    <td class="line-number-row"> 224</td>
    <td class="uncovered-line">          }</td>
</tr><tr>
    <td class="line-number-row"> 225</td>
    <td class="uncovered-line">        }</td>
</tr><tr>
    <td class="line-number-row"> 226</td>
    <td class="covered-line">        't' -> {</td>
</tr><tr>
    <td class="line-number-row"> 227</td>
    <td class="uncovered-line">          // tan or variable.</td>
</tr><tr>
    <td class="line-number-row"> 228</td>
    <td class="covered-line">          if (nextChar == 'a') {</td>
</tr><tr>
    <td class="line-number-row"> 229</td>
    <td class="covered-line">            tokenizeExpectedFunction(name = "tan", isAllowedFunction = false, startIndex, chars)</td>
</tr><tr>
    <td class="line-number-row"> 230</td>
    <td class="covered-line">          } else null // Must be a variable.</td>
</tr><tr>
    <td class="line-number-row"> 231</td>
    <td class="uncovered-line">        }</td>
</tr><tr>
    <td class="line-number-row"> 232</td>
    <td class="covered-line">        else -> null // Must be a variable since no known functions match the first character.</td>
</tr><tr>
    <td class="line-number-row"> 233</td>
    <td class="uncovered-line">      }</td>
</tr><tr>
    <td class="line-number-row"> 234</td>
    <td class="uncovered-line">    }</td>
</tr><tr>
    <td class="line-number-row"> 235</td>
    <td class="uncovered-line"></td>
</tr><tr>
    <td class="line-number-row"> 236</td>
    <td class="uncovered-line">    private fun tokenizeExpectedFunction(</td>
</tr><tr>
    <td class="line-number-row"> 237</td>
    <td class="uncovered-line">      name: String,</td>
</tr><tr>
    <td class="line-number-row"> 238</td>
    <td class="uncovered-line">      isAllowedFunction: Boolean,</td>
</tr><tr>
    <td class="line-number-row"> 239</td>
    <td class="uncovered-line">      startIndex: Int,</td>
</tr><tr>
    <td class="line-number-row"> 240</td>
    <td class="uncovered-line">      chars: PeekableIterator<Char></td>
</tr><tr>
    <td class="line-number-row"> 241</td>
    <td class="uncovered-line">    ): Token {</td>
</tr><tr>
    <td class="line-number-row"> 242</td>
    <td class="covered-line">      return chars.expectNextCharsForFunctionName(name.substring(1), startIndex)</td>
</tr><tr>
    <td class="line-number-row"> 243</td>
    <td class="covered-line">        ?: Token.FunctionName(</td>
</tr><tr>
    <td class="line-number-row"> 244</td>
    <td class="covered-line">          name, isAllowedFunction, startIndex, endIndex = chars.getRetrievalCount()</td>
</tr><tr>
    <td class="line-number-row"> 245</td>
    <td class="uncovered-line">        )</td>
</tr><tr>
    <td class="line-number-row"> 246</td>
    <td class="uncovered-line">    }</td>
</tr><tr>
    <td class="line-number-row"> 247</td>
    <td class="uncovered-line"></td>
</tr><tr>
    <td class="line-number-row"> 248</td>
    <td class="uncovered-line">    private fun tokenizeSymbol(chars: PeekableIterator<Char>, factory: (Int, Int) -> Token): Token {</td>
</tr><tr>
    <td class="line-number-row"> 249</td>
    <td class="covered-line">      val startIndex = chars.getRetrievalCount()</td>
</tr><tr>
    <td class="line-number-row"> 250</td>
    <td class="covered-line">      chars.next() // Parse the symbol.</td>
</tr><tr>
    <td class="line-number-row"> 251</td>
    <td class="covered-line">      val endIndex = chars.getRetrievalCount()</td>
</tr><tr>
    <td class="line-number-row"> 252</td>
    <td class="covered-line">      return factory(startIndex, endIndex)</td>
</tr><tr>
    <td class="line-number-row"> 253</td>
    <td class="uncovered-line">    }</td>
</tr><tr>
    <td class="line-number-row"> 254</td>
    <td class="uncovered-line"></td>
</tr><tr>
    <td class="line-number-row"> 255</td>
    <td class="uncovered-line">    private fun parseInteger(chars: PeekableIterator<Char>): String? {</td>
</tr><tr>
    <td class="line-number-row"> 256</td>
    <td class="covered-line">      val integerBuilder = StringBuilder()</td>
</tr><tr>
    <td class="line-number-row"> 257</td>
    <td class="covered-line">      while (chars.peek() in '0'..'9') {</td>
</tr><tr>
    <td class="line-number-row"> 258</td>
    <td class="covered-line">        integerBuilder.append(chars.next())</td>
</tr><tr>
    <td class="line-number-row"> 259</td>
    <td class="uncovered-line">      }</td>
</tr><tr>
    <td class="line-number-row"> 260</td>
    <td class="covered-line">      return if (integerBuilder.isNotEmpty()) {</td>
</tr><tr>
    <td class="line-number-row"> 261</td>
    <td class="covered-line">        integerBuilder.toString()</td>
</tr><tr>
    <td class="line-number-row"> 262</td>
    <td class="covered-line">      } else null // Failed to parse; no digits.</td>
</tr><tr>
    <td class="line-number-row"> 263</td>
    <td class="uncovered-line">    }</td>
</tr><tr>
    <td class="line-number-row"> 264</td>
    <td class="uncovered-line"></td>
</tr><tr>
    <td class="line-number-row"> 265</td>
    <td class="uncovered-line">    private fun String.toValidDoubleOrNull(): Double? {</td>
</tr><tr>
    <td class="line-number-row"> 266</td>
    <td class="covered-line">      return toDoubleOrNull()?.takeIf { it.isFinite() }</td>
</tr><tr>
    <td class="line-number-row"> 267</td>
    <td class="uncovered-line">    }</td>
</tr><tr>
    <td class="line-number-row"> 268</td>
    <td class="uncovered-line"></td>
</tr><tr>
    <td class="line-number-row"> 269</td>
    <td class="uncovered-line">    /** Represents a token that may act as a unary operator. */</td>
</tr><tr>
    <td class="line-number-row"> 270</td>
    <td class="uncovered-line">    interface UnaryOperatorToken {</td>
</tr><tr>
    <td class="line-number-row"> 271</td>
    <td class="uncovered-line">      /**</td>
</tr><tr>
    <td class="line-number-row"> 272</td>
    <td class="uncovered-line">       * Returns the [MathUnaryOperation.Operator] that would be associated with this token if it's</td>
</tr><tr>
    <td class="line-number-row"> 273</td>
    <td class="uncovered-line">       * treated as a unary operator.</td>
</tr><tr>
    <td class="line-number-row"> 274</td>
    <td class="uncovered-line">       */</td>
</tr><tr>
    <td class="line-number-row"> 275</td>
    <td class="uncovered-line">      fun getUnaryOperator(): MathUnaryOperation.Operator</td>
</tr><tr>
    <td class="line-number-row"> 276</td>
    <td class="uncovered-line">    }</td>
</tr><tr>
    <td class="line-number-row"> 277</td>
    <td class="uncovered-line"></td>
</tr><tr>
    <td class="line-number-row"> 278</td>
    <td class="uncovered-line">    /** Represents a token that may act as a binary operator. */</td>
</tr><tr>
    <td class="line-number-row"> 279</td>
    <td class="uncovered-line">    interface BinaryOperatorToken {</td>
</tr><tr>
    <td class="line-number-row"> 280</td>
    <td class="uncovered-line">      /**</td>
</tr><tr>
    <td class="line-number-row"> 281</td>
    <td class="uncovered-line">       * Returns the [MathBinaryOperation.Operator] that would be associated with this token if it's</td>
</tr><tr>
    <td class="line-number-row"> 282</td>
    <td class="uncovered-line">       * treated as a binary operator.</td>
</tr><tr>
    <td class="line-number-row"> 283</td>
    <td class="uncovered-line">       */</td>
</tr><tr>
    <td class="line-number-row"> 284</td>
    <td class="uncovered-line">      fun getBinaryOperator(): MathBinaryOperation.Operator</td>
</tr><tr>
    <td class="line-number-row"> 285</td>
    <td class="uncovered-line">    }</td>
</tr><tr>
    <td class="line-number-row"> 286</td>
    <td class="uncovered-line"></td>
</tr><tr>
    <td class="line-number-row"> 287</td>
    <td class="uncovered-line">    /** Represents a token that may be encountered during tokenization. */</td>
</tr><tr>
    <td class="line-number-row"> 288</td>
    <td class="uncovered-line">    sealed class Token {</td>
</tr><tr>
    <td class="line-number-row"> 289</td>
    <td class="uncovered-line">      /** The (inclusive) index in the input stream at which point this token begins. */</td>
</tr><tr>
    <td class="line-number-row"> 290</td>
    <td class="uncovered-line">      abstract val startIndex: Int</td>
</tr><tr>
    <td class="line-number-row"> 291</td>
    <td class="uncovered-line"></td>
</tr><tr>
    <td class="line-number-row"> 292</td>
    <td class="uncovered-line">      /** The (exclusive) index in the input stream at which point this token ends. */</td>
</tr><tr>
    <td class="line-number-row"> 293</td>
    <td class="uncovered-line">      abstract val endIndex: Int</td>
</tr><tr>
    <td class="line-number-row"> 294</td>
    <td class="uncovered-line"></td>
</tr><tr>
    <td class="line-number-row"> 295</td>
    <td class="uncovered-line">      /**</td>
</tr><tr>
    <td class="line-number-row"> 296</td>
    <td class="uncovered-line">       * Represents a positive integer (i.e. no decimal point, and no negative sign).</td>
</tr><tr>
    <td class="line-number-row"> 297</td>
    <td class="uncovered-line">       *</td>
</tr><tr>
    <td class="line-number-row"> 298</td>
    <td class="uncovered-line">       * @property parsedValue the parsed value of the integer</td>
</tr><tr>
    <td class="line-number-row"> 299</td>
    <td class="uncovered-line">       */</td>
</tr><tr>
    <td class="line-number-row"> 300</td>
    <td class="covered-line">      class PositiveInteger(</td>
</tr><tr>
    <td class="line-number-row"> 301</td>
    <td class="covered-line">        val parsedValue: Int,</td>
</tr><tr>
    <td class="line-number-row"> 302</td>
    <td class="covered-line">        override val startIndex: Int,</td>
</tr><tr>
    <td class="line-number-row"> 303</td>
    <td class="covered-line">        override val endIndex: Int</td>
</tr><tr>
    <td class="line-number-row"> 304</td>
    <td class="covered-line">      ) : Token()</td>
</tr><tr>
    <td class="line-number-row"> 305</td>
    <td class="uncovered-line"></td>
</tr><tr>
    <td class="line-number-row"> 306</td>
    <td class="uncovered-line">      /**</td>
</tr><tr>
    <td class="line-number-row"> 307</td>
    <td class="uncovered-line">       * Represents a positive real number (i.e. contains a decimal point, but no negative sign).</td>
</tr><tr>
    <td class="line-number-row"> 308</td>
    <td class="uncovered-line">       *</td>
</tr><tr>
    <td class="line-number-row"> 309</td>
    <td class="uncovered-line">       * @property parsedValue the parsed value of the real number as a [Double]</td>
</tr><tr>
    <td class="line-number-row"> 310</td>
    <td class="uncovered-line">       */</td>
</tr><tr>
    <td class="line-number-row"> 311</td>
    <td class="covered-line">      class PositiveRealNumber(</td>
</tr><tr>
    <td class="line-number-row"> 312</td>
    <td class="covered-line">        val parsedValue: Double,</td>
</tr><tr>
    <td class="line-number-row"> 313</td>
    <td class="covered-line">        override val startIndex: Int,</td>
</tr><tr>
    <td class="line-number-row"> 314</td>
    <td class="covered-line">        override val endIndex: Int</td>
</tr><tr>
    <td class="line-number-row"> 315</td>
    <td class="covered-line">      ) : Token()</td>
</tr><tr>
    <td class="line-number-row"> 316</td>
    <td class="uncovered-line"></td>
</tr><tr>
    <td class="line-number-row"> 317</td>
    <td class="uncovered-line">      /**</td>
</tr><tr>
    <td class="line-number-row"> 318</td>
    <td class="uncovered-line">       * Represents a variable.</td>
</tr><tr>
    <td class="line-number-row"> 319</td>
    <td class="uncovered-line">       *</td>
</tr><tr>
    <td class="line-number-row"> 320</td>
    <td class="uncovered-line">       * @property parsedName the name of the variable</td>
</tr><tr>
    <td class="line-number-row"> 321</td>
    <td class="uncovered-line">       */</td>
</tr><tr>
    <td class="line-number-row"> 322</td>
    <td class="covered-line">      class VariableName(</td>
</tr><tr>
    <td class="line-number-row"> 323</td>
    <td class="covered-line">        val parsedName: String,</td>
</tr><tr>
    <td class="line-number-row"> 324</td>
    <td class="covered-line">        override val startIndex: Int,</td>
</tr><tr>
    <td class="line-number-row"> 325</td>
    <td class="covered-line">        override val endIndex: Int</td>
</tr><tr>
    <td class="line-number-row"> 326</td>
    <td class="covered-line">      ) : Token()</td>
</tr><tr>
    <td class="line-number-row"> 327</td>
    <td class="uncovered-line"></td>
</tr><tr>
    <td class="line-number-row"> 328</td>
    <td class="uncovered-line">      /**</td>
</tr><tr>
    <td class="line-number-row"> 329</td>
    <td class="uncovered-line">       * Represents a recognized function name (otherwise sequential letters are treated as</td>
</tr><tr>
    <td class="line-number-row"> 330</td>
    <td class="uncovered-line">       * variables), e.g.: sqrt.</td>
</tr><tr>
    <td class="line-number-row"> 331</td>
    <td class="uncovered-line">       *</td>
</tr><tr>
    <td class="line-number-row"> 332</td>
    <td class="uncovered-line">       * @property parsedName the name of the function</td>
</tr><tr>
    <td class="line-number-row"> 333</td>
    <td class="uncovered-line">       * @property isAllowedFunction whether the function is supported by the parser. This helps</td>
</tr><tr>
    <td class="line-number-row"> 334</td>
    <td class="uncovered-line">       *     with error detection & management while parsing.</td>
</tr><tr>
    <td class="line-number-row"> 335</td>
    <td class="uncovered-line">       */</td>
</tr><tr>
    <td class="line-number-row"> 336</td>
    <td class="covered-line">      class FunctionName(</td>
</tr><tr>
    <td class="line-number-row"> 337</td>
    <td class="covered-line">        val parsedName: String,</td>
</tr><tr>
    <td class="line-number-row"> 338</td>
    <td class="covered-line">        val isAllowedFunction: Boolean,</td>
</tr><tr>
    <td class="line-number-row"> 339</td>
    <td class="covered-line">        override val startIndex: Int,</td>
</tr><tr>
    <td class="line-number-row"> 340</td>
    <td class="covered-line">        override val endIndex: Int</td>
</tr><tr>
    <td class="line-number-row"> 341</td>
    <td class="covered-line">      ) : Token()</td>
</tr><tr>
    <td class="line-number-row"> 342</td>
    <td class="uncovered-line"></td>
</tr><tr>
    <td class="line-number-row"> 343</td>
    <td class="uncovered-line">      /** Represents a square root sign, i.e. 'âˆš'. */</td>
</tr><tr>
    <td class="line-number-row"> 344</td>
    <td class="covered-line">      class SquareRootSymbol(override val startIndex: Int, override val endIndex: Int) : Token()</td>
</tr><tr>
    <td class="line-number-row"> 345</td>
    <td class="uncovered-line"></td>
</tr><tr>
    <td class="line-number-row"> 346</td>
    <td class="uncovered-line">      /** Represents a minus sign, e.g. '-'. */</td>
</tr><tr>
    <td class="line-number-row"> 347</td>
    <td class="covered-line">      class MinusSymbol(</td>
</tr><tr>
    <td class="line-number-row"> 348</td>
    <td class="covered-line">        override val startIndex: Int,</td>
</tr><tr>
    <td class="line-number-row"> 349</td>
    <td class="covered-line">        override val endIndex: Int</td>
</tr><tr>
    <td class="line-number-row"> 350</td>
    <td class="covered-line">      ) : Token(), UnaryOperatorToken, BinaryOperatorToken {</td>
</tr><tr>
    <td class="line-number-row"> 351</td>
    <td class="not-covered-line">        override fun getUnaryOperator(): MathUnaryOperation.Operator = NEGATE</td>
</tr><tr>
    <td class="line-number-row"> 352</td>
    <td class="uncovered-line"></td>
</tr><tr>
    <td class="line-number-row"> 353</td>
    <td class="not-covered-line">        override fun getBinaryOperator(): MathBinaryOperation.Operator = SUBTRACT</td>
</tr><tr>
    <td class="line-number-row"> 354</td>
    <td class="uncovered-line">      }</td>
</tr><tr>
    <td class="line-number-row"> 355</td>
    <td class="uncovered-line"></td>
</tr><tr>
    <td class="line-number-row"> 356</td>
    <td class="uncovered-line">      /** Represents a plus sign, e.g. '+'. */</td>
</tr><tr>
    <td class="line-number-row"> 357</td>
    <td class="covered-line">      class PlusSymbol(</td>
</tr><tr>
    <td class="line-number-row"> 358</td>
    <td class="covered-line">        override val startIndex: Int,</td>
</tr><tr>
    <td class="line-number-row"> 359</td>
    <td class="covered-line">        override val endIndex: Int</td>
</tr><tr>
    <td class="line-number-row"> 360</td>
    <td class="covered-line">      ) : Token(), UnaryOperatorToken, BinaryOperatorToken {</td>
</tr><tr>
    <td class="line-number-row"> 361</td>
    <td class="not-covered-line">        override fun getUnaryOperator(): MathUnaryOperation.Operator = POSITIVE</td>
</tr><tr>
    <td class="line-number-row"> 362</td>
    <td class="uncovered-line"></td>
</tr><tr>
    <td class="line-number-row"> 363</td>
    <td class="not-covered-line">        override fun getBinaryOperator(): MathBinaryOperation.Operator = ADD</td>
</tr><tr>
    <td class="line-number-row"> 364</td>
    <td class="uncovered-line">      }</td>
</tr><tr>
    <td class="line-number-row"> 365</td>
    <td class="uncovered-line"></td>
</tr><tr>
    <td class="line-number-row"> 366</td>
    <td class="uncovered-line">      /** Represents a multiply sign, e.g. '*'. */</td>
</tr><tr>
    <td class="line-number-row"> 367</td>
    <td class="covered-line">      class MultiplySymbol(</td>
</tr><tr>
    <td class="line-number-row"> 368</td>
    <td class="covered-line">        override val startIndex: Int,</td>
</tr><tr>
    <td class="line-number-row"> 369</td>
    <td class="covered-line">        override val endIndex: Int</td>
</tr><tr>
    <td class="line-number-row"> 370</td>
    <td class="covered-line">      ) : Token(), BinaryOperatorToken {</td>
</tr><tr>
    <td class="line-number-row"> 371</td>
    <td class="not-covered-line">        override fun getBinaryOperator(): MathBinaryOperation.Operator = MULTIPLY</td>
</tr><tr>
    <td class="line-number-row"> 372</td>
    <td class="uncovered-line">      }</td>
</tr><tr>
    <td class="line-number-row"> 373</td>
    <td class="uncovered-line"></td>
</tr><tr>
    <td class="line-number-row"> 374</td>
    <td class="uncovered-line">      /** Represents a divide sign, e.g. '/'. */</td>
</tr><tr>
    <td class="line-number-row"> 375</td>
    <td class="covered-line">      class DivideSymbol(</td>
</tr><tr>
    <td class="line-number-row"> 376</td>
    <td class="covered-line">        override val startIndex: Int,</td>
</tr><tr>
    <td class="line-number-row"> 377</td>
    <td class="covered-line">        override val endIndex: Int</td>
</tr><tr>
    <td class="line-number-row"> 378</td>
    <td class="covered-line">      ) : Token(), BinaryOperatorToken {</td>
</tr><tr>
    <td class="line-number-row"> 379</td>
    <td class="not-covered-line">        override fun getBinaryOperator(): MathBinaryOperation.Operator = DIVIDE</td>
</tr><tr>
    <td class="line-number-row"> 380</td>
    <td class="uncovered-line">      }</td>
</tr><tr>
    <td class="line-number-row"> 381</td>
    <td class="uncovered-line"></td>
</tr><tr>
    <td class="line-number-row"> 382</td>
    <td class="uncovered-line">      /** Represents an exponent sign, i.e. '^'. */</td>
</tr><tr>
    <td class="line-number-row"> 383</td>
    <td class="covered-line">      class ExponentiationSymbol(</td>
</tr><tr>
    <td class="line-number-row"> 384</td>
    <td class="covered-line">        override val startIndex: Int,</td>
</tr><tr>
    <td class="line-number-row"> 385</td>
    <td class="covered-line">        override val endIndex: Int</td>
</tr><tr>
    <td class="line-number-row"> 386</td>
    <td class="covered-line">      ) : Token(), BinaryOperatorToken {</td>
</tr><tr>
    <td class="line-number-row"> 387</td>
    <td class="not-covered-line">        override fun getBinaryOperator(): MathBinaryOperation.Operator = EXPONENTIATE</td>
</tr><tr>
    <td class="line-number-row"> 388</td>
    <td class="uncovered-line">      }</td>
</tr><tr>
    <td class="line-number-row"> 389</td>
    <td class="uncovered-line"></td>
</tr><tr>
    <td class="line-number-row"> 390</td>
    <td class="uncovered-line">      /** Represents an equals sign, i.e. '='. */</td>
</tr><tr>
    <td class="line-number-row"> 391</td>
    <td class="covered-line">      class EqualsSymbol(override val startIndex: Int, override val endIndex: Int) : Token()</td>
</tr><tr>
    <td class="line-number-row"> 392</td>
    <td class="uncovered-line"></td>
</tr><tr>
    <td class="line-number-row"> 393</td>
    <td class="uncovered-line">      /** Represents a left parenthesis symbol, i.e. '('. */</td>
</tr><tr>
    <td class="line-number-row"> 394</td>
    <td class="covered-line">      class LeftParenthesisSymbol(</td>
</tr><tr>
    <td class="line-number-row"> 395</td>
    <td class="covered-line">        override val startIndex: Int,</td>
</tr><tr>
    <td class="line-number-row"> 396</td>
    <td class="covered-line">        override val endIndex: Int</td>
</tr><tr>
    <td class="line-number-row"> 397</td>
    <td class="covered-line">      ) : Token()</td>
</tr><tr>
    <td class="line-number-row"> 398</td>
    <td class="uncovered-line"></td>
</tr><tr>
    <td class="line-number-row"> 399</td>
    <td class="uncovered-line">      /** Represents a right parenthesis symbol, i.e. ')'. */</td>
</tr><tr>
    <td class="line-number-row"> 400</td>
    <td class="covered-line">      class RightParenthesisSymbol(</td>
</tr><tr>
    <td class="line-number-row"> 401</td>
    <td class="covered-line">        override val startIndex: Int,</td>
</tr><tr>
    <td class="line-number-row"> 402</td>
    <td class="covered-line">        override val endIndex: Int</td>
</tr><tr>
    <td class="line-number-row"> 403</td>
    <td class="covered-line">      ) : Token()</td>
</tr><tr>
    <td class="line-number-row"> 404</td>
    <td class="uncovered-line"></td>
</tr><tr>
    <td class="line-number-row"> 405</td>
    <td class="uncovered-line">      /** Represents an incomplete function name, e.g. 'sqr'. */</td>
</tr><tr>
    <td class="line-number-row"> 406</td>
    <td class="covered-line">      class IncompleteFunctionName(</td>
</tr><tr>
    <td class="line-number-row"> 407</td>
    <td class="covered-line">        override val startIndex: Int,</td>
</tr><tr>
    <td class="line-number-row"> 408</td>
    <td class="covered-line">        override val endIndex: Int</td>
</tr><tr>
    <td class="line-number-row"> 409</td>
    <td class="covered-line">      ) : Token()</td>
</tr><tr>
    <td class="line-number-row"> 410</td>
    <td class="uncovered-line"></td>
</tr><tr>
    <td class="line-number-row"> 411</td>
    <td class="uncovered-line">      /** Represents an invalid character that doesn't fit any of the other [Token] types. */</td>
</tr><tr>
    <td class="line-number-row"> 412</td>
    <td class="covered-line">      class InvalidToken(override val startIndex: Int, override val endIndex: Int) : Token()</td>
</tr><tr>
    <td class="line-number-row"> 413</td>
    <td class="uncovered-line">    }</td>
</tr><tr>
    <td class="line-number-row"> 414</td>
    <td class="uncovered-line"></td>
</tr><tr>
    <td class="line-number-row"> 415</td>
    <td class="covered-line">    private fun Char.isWhitespace(): Boolean = when (this) {</td>
</tr><tr>
    <td class="line-number-row"> 416</td>
    <td class="covered-line">      ' ', '\t', '\n', '\r' -> true</td>
</tr><tr>
    <td class="line-number-row"> 417</td>
    <td class="covered-line">      else -> false</td>
</tr><tr>
    <td class="line-number-row"> 418</td>
    <td class="covered-line">    }</td>
</tr><tr>
    <td class="line-number-row"> 419</td>
    <td class="uncovered-line"></td>
</tr><tr>
    <td class="line-number-row"> 420</td>
    <td class="uncovered-line">    private fun PeekableIterator<Char>.consumeWhitespace() {</td>
</tr><tr>
    <td class="line-number-row"> 421</td>
    <td class="covered-line">      while (peek()?.isWhitespace() == true) next()</td>
</tr><tr>
    <td class="line-number-row"> 422</td>
    <td class="covered-line">    }</td>
</tr><tr>
    <td class="line-number-row"> 423</td>
    <td class="uncovered-line"></td>
</tr><tr>
    <td class="line-number-row"> 424</td>
    <td class="uncovered-line">    /**</td>
</tr><tr>
    <td class="line-number-row"> 425</td>
    <td class="uncovered-line">     * Expects each of the characters to be next in the token stream, in the order of the string.</td>
</tr><tr>
    <td class="line-number-row"> 426</td>
    <td class="uncovered-line">     * All characters must be present in [this] iterator. Returns non-null if a failure occurs,</td>
</tr><tr>
    <td class="line-number-row"> 427</td>
    <td class="uncovered-line">     * otherwise null if all characters were confirmed to be present. If null is returned, [this]</td>
</tr><tr>
    <td class="line-number-row"> 428</td>
    <td class="uncovered-line">     * iterator will be at the token that comes after the last confirmed character in the string.</td>
</tr><tr>
    <td class="line-number-row"> 429</td>
    <td class="uncovered-line">     */</td>
</tr><tr>
    <td class="line-number-row"> 430</td>
    <td class="uncovered-line">    private fun PeekableIterator<Char>.expectNextCharsForFunctionName(</td>
</tr><tr>
    <td class="line-number-row"> 431</td>
    <td class="uncovered-line">      chars: String,</td>
</tr><tr>
    <td class="line-number-row"> 432</td>
    <td class="uncovered-line">      startIndex: Int</td>
</tr><tr>
    <td class="line-number-row"> 433</td>
    <td class="uncovered-line">    ): Token? {</td>
</tr><tr>
    <td class="line-number-row"> 434</td>
    <td class="covered-line">      for (c in chars) {</td>
</tr><tr>
    <td class="line-number-row"> 435</td>
    <td class="covered-line">        expectNextValue { c }</td>
</tr><tr>
    <td class="line-number-row"> 436</td>
    <td class="covered-line">          ?: return Token.IncompleteFunctionName(startIndex, endIndex = getRetrievalCount())</td>
</tr><tr>
    <td class="line-number-row"> 437</td>
    <td class="uncovered-line">      }</td>
</tr><tr>
    <td class="line-number-row"> 438</td>
    <td class="covered-line">      return null</td>
</tr><tr>
    <td class="line-number-row"> 439</td>
    <td class="uncovered-line">    }</td>
</tr><tr>
    <td class="line-number-row"> 440</td>
    <td class="uncovered-line">  }</td>
</tr><tr>
    <td class="line-number-row"> 441</td>
    <td class="uncovered-line">}</td>
</tr>    </tbody>
  </table>
</body>
</html>|:white_check_mark:|