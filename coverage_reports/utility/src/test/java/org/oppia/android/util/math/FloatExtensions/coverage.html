<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coverage Report</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            padding: 20px;
        }
        .covered-line, .not-covered-line, .uncovered-line {
            display: inline-block;
            width: auto;
            padding: 2px 4px;
            margin: 0;
        }
        .covered-line {
            background-color: #c8e6c9; /* Light green */
        }
        .not-covered-line {
            background-color: #ffcdd2; /* Light red */
        }
        .uncovered-line {
            background-color: #ffffff; /* White */
        }
        .coverage-summary {
            margin-bottom: 20px;
        }
        pre {
            white-space: pre-wrap;
            word-wrap: break-word;
        }
    </style>
</head>
<body>
    <h1>Coverage Report</h1>
    <div class="coverage-summary">
        <h2>Total coverage:</h2>
        <ul>
            <li><strong>Files covered:</strong> 1</li>
            <li><strong>Covered File:</strong> utility/src/main/java/org/oppia/android/util/math/FloatExtensions.kt</li>
            <li><strong>Coverage percentage:</strong> 80.00% covered</li>
            <li><strong>Line coverage:</strong> 0 covered / 0 found</li>
            <li><strong>Function coverage:</strong> 0 covered / 0 found</li>
            <li><strong>Branch coverage:</strong> 0 covered / 0 found</li>
        </ul>
    </div>
    <pre><div class="uncovered-line">   1: package org.oppia.android.util.math</div>
<div class="uncovered-line">   2: </div>
<div class="uncovered-line">   3: import kotlin.math.abs</div>
<div class="uncovered-line">   4: </div>
<div class="uncovered-line">   5: /**</div>
<div class="uncovered-line">   6:  * The error margin used for approximately [Float] equality checking, that is, the largest distance</div>
<div class="uncovered-line">   7:  * from any particular number before a new value will be considered unequal (i.e. all values between</div>
<div class="uncovered-line">   8:  * a float and (float-interval, float+interval) will be considered equal to the float).</div>
<div class="uncovered-line">   9:  *</div>
<div class="uncovered-line">  10:  * Note that the machine epsilon value from https://en.wikipedia.org/wiki/Machine_epsilon is defined</div>
<div class="uncovered-line">  11:  * defined as the smallest value that, when added to, or subtract from, 1, will result in a value</div>
<div class="uncovered-line">  12:  * that is exactly equal to 1. A larger value is picked here for more allowance in variance.</div>
<div class="uncovered-line">  13:  */</div>
<div class="uncovered-line">  14: const val FLOAT_EQUALITY_EPSILON: Float = 1e-6f</div>
<div class="uncovered-line">  15: </div>
<div class="uncovered-line">  16: /**</div>
<div class="uncovered-line">  17:  * The error margin used for approximately [Double] equality checking.</div>
<div class="uncovered-line">  18:  *</div>
<div class="uncovered-line">  19:  * See [FLOAT_EQUALITY_EPSILON] for an explanation of this value.</div>
<div class="uncovered-line">  20:  */</div>
<div class="uncovered-line">  21: const val DOUBLE_EQUALITY_EPSILON: Double = 1e-13</div>
<div class="uncovered-line">  22: </div>
<div class="uncovered-line">  23: /**</div>
<div class="uncovered-line">  24:  * Returns whether this float approximately equals another based on a consistent epsilon value</div>
<div class="uncovered-line">  25:  * ([FLOAT_EQUALITY_EPSILON]).</div>
<div class="uncovered-line">  26:  */</div>
<div class="uncovered-line">  27: fun Float.isApproximatelyEqualTo(other: Float): Boolean {</div>
<div class="covered-line">  28:   return abs(this - other) < FLOAT_EQUALITY_EPSILON</div>
<div class="uncovered-line">  29: }</div>
<div class="uncovered-line">  30: </div>
<div class="uncovered-line">  31: /**</div>
<div class="uncovered-line">  32:  * Returns whether this double approximately equals another based on a consistent epsilon value</div>
<div class="uncovered-line">  33:  * ([DOUBLE_EQUALITY_EPSILON]).</div>
<div class="uncovered-line">  34:  */</div>
<div class="uncovered-line">  35: fun Double.isApproximatelyEqualTo(other: Double): Boolean {</div>
<div class="covered-line">  36:   return abs(this - other) < DOUBLE_EQUALITY_EPSILON</div>
<div class="uncovered-line">  37: }</div>
<div class="uncovered-line">  38: </div>
<div class="uncovered-line">  39: /**</div>
<div class="uncovered-line">  40:  * Returns a string representation of this [Double] that keeps the double in pure decimal and never</div>
<div class="uncovered-line">  41:  * relies on scientific notation (unlike [Double.toString]).</div>
<div class="uncovered-line">  42:  */</div>
<div class="not-covered-line">  43: fun Double.toPlainString(): String = toBigDecimal().toPlainString()</div>
    </pre>
</body>
</html>